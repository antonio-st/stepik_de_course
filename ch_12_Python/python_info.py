 
# ======================= строки =============================

# считывание данных
num1, num2, num3 = int(input()), int(input()), int(input())
stage1, stage2, stage3 = [int(input()) for _ in range(3)]

# три ввода в список
results = [int(input()) for _ in range(3)]
values = {int(input()) for i in range(3)}

print(w_3[1])
print(w_3[6:12])
print(f"{w_3[0:12:2]} | с интервалом 2")
print(w_4[::-1]) # развернуть строку


# округление
round(sum(numbers1) / len(numbers1), 1)

# целое деление
3660 // 3600 = 1
125 // 60 = 2
# остаток от деления
3660 % 3600 = 60
3725 % 3600 = 125
3725 % 60 = 5


# замена символов с строке
input_string = input().replace(" ", "")

# длина строки
len(text)

print(f"Верхний регистр: {text.upper()}")
print(f"Нижний регистр: {text.lower()}")


print(f"Количество вхождений слова 'hello': {text.count(text)}")

# разбить строку
text.split("@")

# Метод capitalize() в Python возвращает копию строки, в которой первая буква переведена в верхний регистр
text.capitalize()
# Если нужно сделать заглавными первые буквы всех слов в строке, следует использовать метод title()
text.title()

# самое длинное слово в списке
max(split_str, key=len)

## развернуть список слов
# разбиваем слова по пробелу
str_to_list = input_string.split(" ")
# разворачиваем список, преобразуем в строку
list_to_str = " ".join(str_to_list[::-1])

# список в строку 2
*list_to_str



# ============================ if ===============================

x = 0
if x > 0:
    print("x больше 0")
elif x==0:
    print("x равно 0")
else:
    print("x меньше 0")
    
# Тернарный оператор

status = "Совершеннолетний" if age >= 18 else "Несовершеннолетний"

# AND и OR

x = 7
y = 12
if (x > 5 and x < 10) or y == 12:
    print("Либо x в диапазоне от 5 до 10, либо y равно 12.")


# сортировка списка
sorted([a, b, c]

# ======================= цикл for =============================

for i in range(3, 5):
    print(i)
# обратное направление
for i in range(100,1,-1):
    print(i)

# сумма чисел
sum_total = 0
for i in range(1, 101):
    sum_total += i
print("Сумма чисел от 1 до 100:", sum_total)

# найти символ в строке
string = "abracadabra"
count = 0
for char in string:
    if char == 'a':
        count += 1
print(f"Символ 'a' встречается {count} раз.")

# факториал
n = 5
factorial = 1

for i in range(1, n + 1):
    factorial *= i

# вывести True
any(i < 50 for i in lst)
if len([i for i in hours if i > 90]) >= 1

# проверка спец символов / двойной цикл в list compr
list_char = ["!", "@", "#", "$", "%", "&", "*"]
chk_char = 1 if [1 for i in pass_check for j in list_char if i in j] else 0

#  проверка большой буквы
any(1 for i in pass_check if i.isupper() is True)

# проверка чиселки в пароле
is_dig = any(1 for i in pass_check if i.isdigit() is True)


# ======================= цикл while =============================

while условие:
    # блок кода, который выполняется, пока условие истинно

i = 1
while i <= 5:
    print(i)
    i += 1  # Увеличиваем значение переменной на 1, чтобы избежать бесконечного цикла

secret_number = 7
guess = 0
while guess != secret_number:
    guess = int(input("Угадайте число: "))
    if guess == secret_number:
        print("Вы угадали!")
    else:
        print("Неправильно, попробуйте снова!")

# сумма чисел
input_num = input()
len_num = len(input_num)
acc = 0
while len_num > 0:
    len_num -= 1
    acc += int(input_num[len_num - 1])


# ======================= break, continue и pass =============================

# Оператор break:
#     Что делает: Прерывает выполнение цикла и выходит из него полностью, независимо от того, выполнены ли остальные итерации. Цикл завершается, и управление передаётся следующей строке кода после цикла.
#     Когда использовать: Когда нужно досрочно завершить цикл, если выполнено определённое условие.

for i in range(1, 11):
    if i == 5:
        break  # Прерывает цикл, когда i равно 5
    print(i)

# Оператор continue:
    # Что делает: Пропускает текущую итерацию цикла и переходит к следующей, не завершая весь цикл.
    # Когда использовать: Когда нужно пропустить определённые итерации цикла, но продолжить выполнение остальных.
for i in range(1, 6):
    if i == 3:
        continue  # Пропускает текущую итерацию, когда i равно 3
    print(i)

# Оператор pass:
# Ничего не делает, это просто заглушка. Он нужен для тех случаев, когда по синтаксическим правилам должен быть блок кода,
# но по логике на данном этапе выполнения никакие действия не требуются.
# Это может быть полезно при написании скелета программы или для временной заглушки кода.

# ======================= tuple_list_dict_set =============================

## list (список)

# Изменяемость (mutable): Вы можете изменять список после его создания (добавлять, удалять, изменять элементы).
# Упорядоченность: Порядок элементов сохраняется, и каждый элемент имеет индекс.
# Допускает повторяющиеся элементы: Один и тот же элемент может встречаться в списке несколько раз.
# Индексация: Элементы можно обращаться по индексу, начиная с 0.
# clear(): очищает весь список.
my_list = [1, 2, 3, 4]

# append(): добавляет элемент в конец списка.
# insert(): добавляет элемент по указанному индексу.
# remove(): удаляет первый встречный элемент по значению. Удалит только один раз первый элемент.
# pop(): удаляет элемент по индексу и возвращает его (по умолчанию последний элемент).

my_list.remove(2)       # останется [1, 3, 4]
my_list.pop(1)          # останется [1, 4]
my_list.clear()         # останется []
# изменение элемента
my_list[1] = 25         # [10, 25, 30]
# Длина списка
len(my_list) #3

my_list.append(4)       # [1, 2, 3, 4]
my_list.insert(1, "a")  # [1, "a", 2, 3, 4]

# срезы
print(my_list[1:4]) # Вывод: [2, 3, 4]



## set (множество)

# Изменяемая (mutable) неупорядоченная коллекция уникальных элементов.
# Множества не допускают дублирующихся значений и не поддерживают индексацию.
# Множества создаются с помощью фигурных скобок {} или функции set().
# Когда использовать: Когда нужна неупорядоченная коллекция без повторяющихся элементов, например,
# для удаления дубликатов или операций над множествами.
my_set = {1, 2, 3, 3, 4, 5} # Вывод: {1, 2, 3, 4, 5}

my_set = {1, 2, 3, 4, 5}

my_set.remove(6) # KeyError: 6 Элемента нет
my_set.discard(6) # ошибки не будет
my_set.discard(5) # {1, 2, 3, 4}
my_set.add(5) # {1, 2, 3, 4, 5}

# пересечение множеств
# intersection(other_set) или &: возвращает новое множество с элементами, которые присутствуют в обоих множествах.
my_set = {1, 2, 3, 4, 5}
my_set_2 = {3, 4, 5, 6}
my_set & my_set_2 # {3, 4, 5}

# объединение
# union(other_set) или |: возвращает новое множество, содержащее все элементы обоих множеств.

my_set | my_set_2 # {1, 2, 3, 4, 5, 6}

# difference(other_set) или - : возвращает новое множество с элементами, которые присутствуют в первом множестве,
# но отсутствуют во втором.
my_set - my_set_2 # {1, 2}


# symmetric_difference(other_set) или ^: возвращает новое множество с элементами, которые присутствуют в одном из
# множеств, но не в обоих.
my_set ^ my_set_2 # {1, 2, 6}





## dict (словарь)

# Изменяемая (mutable) коллекция пар "ключ-значение". Ключи должны быть уникальными и неизменяемыми
# (например, строка, число или кортеж).
# Словари создаются с помощью фигурных скобок {} или функции dict().

my_dict = {"name": "Alice", "age": 25}
my_dict = dict(name="Alice", age=25, city="New York")
print(my_dict["name"])        # Доступ по ключу, вывод: Alice
my_dict["city"] = "New York"  # Добавление пары ключ-значение
# Если ключ уже существует, его значение будет обновлено.
# Если ключа нет, он будет добавлен.

# Удаление элементов
#     del my_dict[key]: удаляет элемент по ключу.
#     pop(key): удаляет элемент и возвращает его значение.
#     popitem(): удаляет последнюю добавленную пару ключ-значение (актуально для версии Python 3.7+).
#     clear(): удаляет все элементы из словаря.

my_dict = {"a": 1, "b": 2, "c": 3}
my_dict.pop("b")          # Удаляет ключ 'b'
print(my_dict)             # Вывод: {'a': 1, 'c': 3}

# Доступ к значениям
#     Через квадратные скобки my_dict[key].
#     Метод get(key, default): возвращает значение по ключу, если его нет — возвращает значение по умолчанию.
my_dict = {"a": 1, "b": 2}
print(my_dict.get("a"))     # Вывод: 1
print(my_dict.get("z", 0))  # Вывод: 0, так как ключа "z" нет

# Проверка наличия ключа
#     in проверяет, есть ли ключ в словаре.
if "a" in my_dict:
    print("Ключ 'a' есть в словаре")

# Перебор элементов словаря
#     keys(): возвращает все ключи.
#     values(): возвращает все значения.
#     items(): возвращает пары ключ-значение в виде кортежей.
my_dict = {"a": 1, "b": 2, "c": 3}
for key in my_dict.keys():
    print(key)              # Вывод: a b c
for value in my_dict.values():
    print(value)            # Вывод: 1 2 3
for key, value in my_dict.items():
    print(key, value)       # Вывод: a 1, b 2, c 3

text = "hello world"
frequency = {}

# словарь для подсчета частоты элементов.
for char in text:
    if char in frequency:
        frequency[char] += 1
    else:
        frequency[char] = 1
print(frequency)  # Вывод: {'h': 1, 'e': 1, 'l': 3, 'o': 2, ' ': 1, 'w': 1, 'r': 1, 'd': 1}




## tuple (кортеж)

# Неизменяемая (immutable) упорядоченная коллекция элементов.
# Как и списки, кортежи поддерживают индексацию, но их содержимое нельзя изменять после создания.
# Когда использовать: Когда требуется упорядоченная, но неизменяемая коллекция элементов
# (например, для хранения неизменяемых данных).

# Кортежи создаются с помощью круглых скобок ().
# Создание кортежа с числами
my_tuple = (1, 2, 3)
# Создание кортежа без скобок
my_tuple = 1, 2, 3

my_tuple = (1, )
# взятие элементов так же как в списке с 0 и -1

#
#     Кортежи неизменяемы, поэтому добавить, удалить или изменить элемент нельзя.
#     Если нужно изменить кортеж, можно преобразовать его в список, изменить, а затем вернуть кортеж.

my_tuple = (1, 2, 3)
my_list = list(my_tuple)  # Преобразование в список
my_list[0] = 10
my_tuple = tuple(my_list) # Преобразование обратно в кортеж
print(my_tuple)           # Вывод: (10, 2, 3)

# Кортежи можно объединять (конкатенация) и умножать (повторение).

tuple1 = (1, 2, 3)
tuple2 = (4, 5)
print(tuple1 + tuple2)    # Вывод: (1, 2, 3, 4, 5)
print(tuple1 * 2)         # Вывод: (1, 2, 3, 1, 2, 3)

print(len(my_tuple))      # Длина, вывод: 3

my_tuple = (1, 2, 3)
for item in my_tuple:
    print(item)

# оператор in, чтобы проверить, присутствует ли элемент в кортеже.

my_tuple = (1, 2, 3)
print(2 in my_tuple)     # Вывод: True
print(5 in my_tuple)     # Вывод: False

# можно распаковывать
my_tuple = (1, 2, 3)
a, b, c = my_tuple

# кортежи являются неизменяемыми, поэтому их можно использовать в качестве ключей
# в словарях (в отличие от списков)

location_data = {
    (40.7128, -74.0060): "New York",
    (34.0522, -118.2437): "Los Angeles"
}
print(location_data[(40.7128, -74.0060)])  # Вывод: New York


# Из особенностей -
#     Неизменяемость: После создания кортеж нельзя изменить — элементы нельзя добавить, удалить или изменить.
#     Упорядоченность: Элементы кортежа хранятся в определённом порядке, и их можно получить по индексу.
#     Допускаются дубликаты: В кортежах могут быть повторяющиеся значения.
#     Разные типы данных: Кортежи могут содержать элементы разных типов (числа, строки, списки и т. д.).


## массив (array)
# В Python массив (array) — это структура данных, похожая на список (list), которая хранит последовательность элементов
# одного типа (например, только целые числа или только строки). В отличие от списков, массивы более эффективны для
# хранения данных фиксированного типа и предоставляют меньше функциональности, но быстрее обрабатываются, особенно
# при выполнении математических операций.
import array
# Создание массива целых чисел
arr = array.array('i', [1, 2, 3, 4, 5])
# с плавающей запятой
arr_float = array.array('f', [1\.0, 2.0, 3.0, 4.0, 5.0])


# сумма чисел, функциональный стиль
sum(map(int,nums))

# сумма чисел в списке(список str)
res_num = sum(map(int, input_num))

# groupby группировка одинаковых элементов
x.sort()

for i, j in groupby(x):
    print(i, list(j))